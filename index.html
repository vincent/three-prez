<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Three.js - Un moteur 3D Javascript</title>

    <meta name="description" content="Présentation de Three.js, un moteur 3D Javascript">
    <meta name="author" content="Vincent Lark">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/default.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <link rel="stylesheet" href="lib/css/style.css">

    <style>
      .copy-left {
         display: inline-block;
         text-align: right;
         margin: 0;
        -moz-transform: scaleX(-1);
        -o-transform: scaleX(-1);
        -webkit-transform: scaleX(-1);
        transform: scaleX(-1);
        filter: FlipH;
        -ms-filter: "FlipH";
      }
    </style>

    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">

        <section>
          <h1>Three.js</h1>
          <h3>Un moteur 3D Javascript</h3>
          <br>
          <p>
            <small><span class="copy-left">&copy;</span> <a href="#">Vincent Lark</a>&nbsp;&nbsp;/&nbsp;&nbsp;<a href="http://twitter.com/allyouneedisgnu"> @allyouneedisgnu</a></small>
          </p>
        </section>

        <section>
          <section>
            <aside class="notes">
              <ul>
                <li>Three.js est une librairie open source facilitant l'utilisation de WebGL</li>
                <li>Créée en 2010 par Ricardo Cabello connu comme MrDoob</li>
                <li>Je vous ai mis quelques stats sur le projet</li>
                <li>qui donnent, je trouve, une bonne idée de l'activité, de la popularité, et de l'ouverture de ce projet<br></li>

                <li>Point sur WebGL</li>
                <li>Qui connait ?</li>
                <li>Petit rappel au cas où</li>
                <li>BAS</li>
              </ul>
            </aside>
            <h2>Three.js</h2>
            <br>
            <ul style="width:90%; margin:0">
              <li>
                librairie open source facilitant l'utilisation de WebGL
                <br>
                <a href="http://github.com/mrdoob/three.js">github.com/mrdoob/three.js</a>
                <br><br>
              </li>
              <li>
                créée en <a>2010</a> par <a href="http://twitter.com/@mrdoob">Ricardo Cabello</a>
                <img src="lib/img/mrdoob.png" style="border:none; float:right"/>
                <br><br>
              </li>
              <li>
                <a href="">8000</a> commits, <a href="">59</a> releases, <a href="">300</a> contributors
                <br><br>
              </li>
            </ul>
          </section>
          <aside class="notes">
            <ul>
              <li>OpenGL ES (Open Graphics Library for Embedded System)</li>
            </ul>
          </aside>
          <section>
            <h2>WebGL ?</h2>
            <br>
            <p>&laquo; WebGL est une <a href="">[API]</a>.
            <br><br>
            Elle permet d'utiliser <a href="">OpenGL</a> ES au sein d'une page web [..] HTML5
            <br><br>
            en s'aidant de <a href="">JavaScript</a>, [..] de l'accélération matérielle pour les 
            <br><br>
            calculs et le rendu 3D [..] et du <a href="">processeur graphique</a> &raquo;</p>
          </section>
          <section>
            <img src="lib/img/iknowsomewords.jpg" style="border:none; width:80%"/>
          </section>
          <section>
            <aside class="notes">
              <ul>
                <li>Petit rappels</li>
                <li>Définitions communes à OpenGL et Three.js</li>
              </ul>
            </aside>
            <h2>Vocabulaire</h2>
            <p>Une scène</p>
            <img src="lib/img/scene.png" style="border:none"/>
          </section>
          <section>
            <aside class="notes">
              <ul>
                <li>Avec des méthodes similaires à OpenGL<br></li>
                <li>on manipule des tableaux de points et de faces<br></li>
                <li>et on utilise des matrices pour changer de réferentiel et déplacer les objets<br></li>
              </ul>
            </aside>
            <h2>OK mais concrètement ?</h2>
            <br>
            <ul>
              <li>
                Via des méthodes très similaires à <a href="#">OpenGL</a>
                <code data-trim><pre>
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                </pre></code>
              </li>
              <li>
                On manipule des tableaux de <a href="#">points 3D</a> et de <a href="#">faces</a>
                <code data-trim><pre>
var vertices = [
//  X     Y     Z
  -1.0, -1.0,  1.0,
   1.0, -1.0,  1.0,
   1.0,  1.0,  1.0,
  -1.0,  1.0,  1.0,
                </pre></code>
              </li>
              <li>
                On place des objets en transformant des <a href="">matrices</a>
                <code data-trim><pre>
mvPushMatrix();
mvRotate(cubeRotation, [1, 0, 1]);
mvTranslate([cubeXOffset, cubeYOffset, cubeZOffset]);
                </pre></code>
              </li>
            </ul>
            <br>
          </section>
          <section>
            <aside class="notes">
              <ul>
                <li>Passage en revue du code, des commentaires</li>
                <li>...</li>
                <li>Je sais pas pour vous.. mais moi, ça ne me fait pas spécialement envie..</li>
                <li>Alors, qu'est-ce que j'ai envie ?</li>
              </ul>
            </aside>
            <h2>Exemple, pour un cube</h2>
            <br>
            <pre><code data-trim contenteditable>

// Initialize WebGL, returning the GL context
gl = canvas.getContext("experimental-webgl");

// Create a buffer for the cube's vertices.

cubeVerticesBuffer = gl.createBuffer();

// Select the cubeVerticesBuffer as the one to apply vertex
// operations to from here out.

gl.bindBuffer(gl.ARRAY_BUFFER, cubeVerticesBuffer);

// Now create an array of vertices for the cube.

var vertices = [
  // Front face
  -1.0, -1.0,  1.0,
   1.0, -1.0,  1.0,
   1.0,  1.0,  1.0,
  -1.0,  1.0,  1.0,
  
  // Back face
  -1.0, -1.0, -1.0,
  -1.0,  1.0, -1.0,
   1.0,  1.0, -1.0,
   1.0, -1.0, -1.0,
  
  // Top face
  -1.0,  1.0, -1.0,
  -1.0,  1.0,  1.0,
   1.0,  1.0,  1.0,
   1.0,  1.0, -1.0,
  
  // Bottom face
  -1.0, -1.0, -1.0,
   1.0, -1.0, -1.0,
   1.0, -1.0,  1.0,
  -1.0, -1.0,  1.0,
  
  // Right face
   1.0, -1.0, -1.0,
   1.0,  1.0, -1.0,
   1.0,  1.0,  1.0,
   1.0, -1.0,  1.0,
  
  // Left face
  -1.0, -1.0, -1.0,
  -1.0, -1.0,  1.0,
  -1.0,  1.0,  1.0,
  -1.0,  1.0, -1.0
];

// Now pass the list of vertices into WebGL to build the shape. We
// do this by creating a Float32Array from the JavaScript array,
// then use it to fill the current vertex buffer.

gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

// Now set up the colors for the faces. We'll use solid colors
// for each face.

var colors = [
  [1.0,  1.0,  1.0,  1.0],    // Front face: white
  [1.0,  0.0,  0.0,  1.0],    // Back face: red
  [0.0,  1.0,  0.0,  1.0],    // Top face: green
  [0.0,  0.0,  1.0,  1.0],    // Bottom face: blue
  [1.0,  1.0,  0.0,  1.0],    // Right face: yellow
  [1.0,  0.0,  1.0,  1.0]     // Left face: purple
];

// Convert the array of colors into a table for all the vertices.

var generatedColors = [];

for (j=0; j<6; j++) {
  var c = colors[j];
  
  // Repeat each color four times for the four vertices of the face
  
  for (var i=0; i<4; i++) {
    generatedColors = generatedColors.concat(c);
  }
}

cubeVerticesColorBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, cubeVerticesColorBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(generatedColors), gl.STATIC_DRAW);

// Build the element array buffer; this specifies the indices
// into the vertex array for each face vertices.

cubeVerticesIndexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVerticesIndexBuffer);

// This array defines each face as two triangles, using the
// indices into the vertex array to specify each triangle
// position.

var cubeVertexIndices = [
  0,  1,  2,      0,  2,  3,    // front
  4,  5,  6,      4,  6,  7,    // back
  8,  9,  10,     8,  10, 11,   // top
  12, 13, 14,     12, 14, 15,   // bottom
  16, 17, 18,     16, 18, 19,   // right
  20, 21, 22,     20, 22, 23    // left
]

// Now send the element array to GL

gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
    new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
}

//
// drawScene
//
// Draw the scene.
//
function drawScene() {
// Clear the canvas before we start drawing on it.

gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

// Establish the perspective with which we want to view the
// scene. Our field of view is 45 degrees, with a width/height
// ratio of 640:480, and we only want to see objects between 0.1 units
// and 100 units away from the camera.

perspectiveMatrix = makePerspective(45, 640.0/480.0, 0.1, 100.0);

// Set the drawing position to the "identity" point, which is
// the center of the scene.

loadIdentity();

// Now move the drawing position a bit to where we want to start
// drawing the cube.

mvTranslate([-0.0, 0.0, -6.0]);

// Save the current matrix, then rotate before we draw.

mvPushMatrix();
mvRotate(cubeRotation, [1, 0, 1]);
mvTranslate([cubeXOffset, cubeYOffset, cubeZOffset]);

// Draw the cube by binding the array buffer to the cube vertices
// array, setting attributes, and pushing it to GL.

gl.bindBuffer(gl.ARRAY_BUFFER, cubeVerticesBuffer);
gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);

// Set the colors attribute for the vertices.

gl.bindBuffer(gl.ARRAY_BUFFER, cubeVerticesColorBuffer);
gl.vertexAttribPointer(vertexColorAttribute, 4, gl.FLOAT, false, 0, 0);

// Draw the cube.

gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVerticesIndexBuffer);
setMatrixUniforms();
gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

// Restore the original matrix

mvPopMatrix();
            </code></pre>
          </section>
        </section>

        <section>
          <aside class="notes">
Voila un bon résumé de ce dont j'ai envie. 
La possibilité d'utiliser OpenGL, de manipuler des objets 3D, des particules animées.
<br><br>
Mais plus facilement, et en gardant un code bien lisible.
          </aside>
          <h3>What do we want ?</h3>
          <br>
          <h3><a href="">Object oriented 3D !
          <br>
          and particules !
          <br>
          <br>
          and awesomeness !</a></h3>
          <br>
          <h3>How do we want ?</h3>
          <br>
          <h3><a href="">Super easy ! and readable !</a></h3>
          <br>
        </section>

        <section>
          <aside class="notes">
            Vous l'avez compris, je pense que Three.js répond bien à ces besoins.
            <br>
            Certains ont un peu de mal à croire à la 3D dans le navigateur
            Que ça reste non distribuable (pas de support, buggé)
            Et bien en fait on s'apperçoit que ça commence à arriver pour le "grand public"
            <br><br>
            Voici quelques exemples que je trouve assez parlants
          </aside>
          <h2>De la 3D dans le browser</h2>
          <p>ça marche vraiment ?</p>
          <br>
            <ul>
              <li class="fragment fade-in" data-fragment-index="1">
                Éditeurs 3D en ligne<br>
                <a href="https://clara.io/">Clara.io</a> et <a href="http://verold.com/">Verold</a>
                <br><br>
              </li>
              <li class="fragment fade-in" data-fragment-index="2">
                <a href="#">Chrome Experiments</a><br>
                Visualisations, clips intéractifs
                <br><br>
              </li>
              <li class="fragment fade-in" data-fragment-index="3">
                Marketting / publicité<br>
                <a href="http://gravitymovie.warnerbros.com">Warner</a> Gravity, The Hobbit</a>
                <br>
                <a href="http://www.findyourwaytooz.com/">Disney</a> Magicien d'Oz</a>
                <br>
                <a href="http://www.nike.com/xp/b/genealogyofthefree/zoetrope.html">Nike</a>
                <br>
                <br>
              </li>
              <li class="fragment fade-in" data-fragment-index="4">
                <a href="https://github.com/mrdoob/three.js/tree/master/examples">200+</a> examples spécifiques fournis
                <br>
                ~ tests unitaires, à utiliser comme base 
              </li>
            </ul>
          </ul>
        </section>

        <section>
          <h2>En scène <em>(3D)</em> !</h2>
          <ul>
            <li>une scène, et une camera
              <pre><code data-trim contenteditable>
var camera = new THREE.PerspectiveCamera(45, w/h, 1, 1000)
camera.position.z = 300 // vers vous
var scene = new THREE.Scene()
              </code></pre>
              <br>
            </li>
            <li>un objet (Mesh) composé de sa Geometry et d'un Material
              <pre><code data-trim contenteditable>
var cube = new THREE.Mesh(
  new THREE.CubeGeometry(50, 50, 50),
  new THREE.MeshBasicMaterial({ color: 0x000 })
)
scene.add(cube)
              </code></pre>
              <br>
            </li>
            <li>le renderer expose la scene
              <pre><code data-trim contenteditable>
var renderer = new THREE.WebGLRenderer()
renderer.render(scene, camera)
              </code></pre>
              <br>
            </li>
          </ul>
        </section>

        <section>
          <h2>HOÔoo</h2>
          <!--
          <pre style="width: 60%; float:left"><code data-trim contenteditable style="font-size:18px; max-height:475px;">
var renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(document.body.clientWidth, document.body.clientHeight);
document.body.appendChild(renderer.domElement);
renderer.setClearColorHex(0xEEEEEE, 1.0);
renderer.clear();

var fov = 45; // camera field-of-view in degrees
var width = renderer.domElement.width;
var height = renderer.domElement.height;
var aspect = width / height; // view aspect ratio
var near = 1; // near clip plane
var far = 10000; // far clip plane
var camera = new THREE.PerspectiveCamera( fov, aspect, near, far );
camera.position.z = 300;

var scene = new THREE.Scene();
var cube = new THREE.Mesh(
  new THREE.CubeGeometry(50,50,50),
  new THREE.MeshBasicMaterial({color: 0x000 })
);
scene.add(cube);

var light = new THREE.SpotLight();
light.position.set( 170, 330, -160 );
scene.add(light);

renderer.render(scene, camera);
            </code></pre>
            -->
          <iframe data-src="lib/examples/ex1.html" style="width: 80%; height: 500px"></iframe>
          <p>wait for it ...</p>
        </section>

        <section>
          <ul>
            <li>déplaçons un peu la caméra
              <pre><code data-trim contenteditable>
camera.position.z = 300;  // toujours vers vous
camera.position.y = 60;   // mais un peu plus haut
              </code></pre>
              <br>
            </li>

            <li>utilisons le <a>MeshNormalMaterial</a>, qui affecte aux faces une couleur en fonction de l'angle avec lequel la lumière arrive dessus
              <pre><code data-trim contenteditable>
var cube = new THREE.Mesh(
  new THREE.CubeGeometry(50,50,50),
  new THREE.MeshNormalMaterial()
);
cube.geometry.computeFaceNormals();
              </code></pre>
              <br>
            </li>

            <li>déplaçons un peu le cube
              <pre><code data-trim contenteditable>
cube.rotation.y = 45 * Math.PI / 180;
              </code></pre>
              <br><br>
            </li>
          </ul>

          <aside class="notes">
            L'angle est calculé par rapport aux normals, il faut donc les calculer d'abord 
          </aside>
        </section>

        <section>
          <h2>HOÔoo</h2>
          <iframe data-src="lib/examples/ex1.1.html" style="width: 80%; height: 500px"></iframe>
        </section>

        <section>
          <h2>C'est bien joli, mais bon..</h2>
          <p>On veut que ça bouge !</p>
          <br>
          <ul style="width:55%; float:left">
            <li>
              <a href="">requestAnimationFrame(animate)</a>
            </li>
            <li>
              <pre class="fragment fade-in" data-fragment-index="1"><code data-trim contenteditable>
function animate() {

  camera.position.set(
    Math.sin(t / 1000) * 300,
    150,
    Math.cos(t / 1000) * 300
  );

  requestAnimationFrame(animate)

}
              </code></pre>
            </li>
          </ul>
          <div class="fragment fade-in" data-fragment-index="2">
            <small>ex 2</small>
            <iframe data-src="lib/examples/ex2.html" style="width: 40%; float:right; height: 500px"></iframe>
          </div>
        </section>

        <section>
          <h2>Pas la caméra, la scène !</h2>
          <br>
          <ul style="width:55%; float:left">
            <li>
              <a href="">requestAnimationFrame(animate)</a>
            </li>
            <li>
              <pre><code data-trim contenteditable>
function animate() {

  cube1.position.set(
    Math.sin(t / 1000) * 200,
    150,
    Math.cos(t / 1000) * 200
  );

  cube2.rotation.y = 
              Math.sin(t/1000);

  requestAnimationFrame(animate)
}
              </code></pre>
            </li>
          </ul>
          <div class="fragment fade-in" data-fragment-index="2">
            <small>ex 2.2</small>
            <iframe data-src="lib/examples/ex2.2.html" style="width: 40%; float:right; height: 500px"></iframe>
          </div>
        </section>

        <section>
          <h2>Hiérarchie d'objets</h2>
          Pour déplacer un ensemble d'objets
          <br>
          <pre><code style="float:left; margin-top: 45px; max-height: 500px" data-trim contenteditable>

var group = new THREE.Object3D()
var cube1 = new THREE.Mesh(..)
cube.rotation.y 
      = 45 * Math.PI / 180
var cube2 = new THREE.Mesh(..)
cube2.position.y = 50

group.add(cube1)
group.add(cube2)

scene.add(group)

// group.position
// group.rotation
// group.scale 
          </code></pre>
          <div class="fragment fade-in" data-fragment-index="1">
            <small>ex 2.2.5</small>
            <iframe data-src="lib/examples/ex2.2.5.html" style="width: 40%; float:right; height: 500px"></iframe>
          </div>
        </section>

        <section>
          <h2>Prêts ? Chargez !</h2>
          <ul>
            <li>
              Des images
              <br>
              <pre><code data-trim contenteditable>
var texture = new THREE.Texture()
var loader = new THREE.ImageLoader(manager)

loader.load('textures/UV_Grid_Sm.jpg', function (image) {
  texture.image = image
})
              </code></pre>
              <br>
            </li>
            <li>
              Des fichiers 3D  .obj ,  .stl ,  .fbx , ...
              <br>
              <pre><code data-trim contenteditable>
var loader = new THREE.OBJLoader(manager)

loader.load('obj/male02/male02.obj', function (object) {
  scene.add(object)
})
              </code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h2>Créons un objet 3D</h2>
          <br>
          <ul style="margin-top: 45px; width:55%; float:left">
            <li>
              Création d'un objet dans <a href="http://www.blender.org">Blender</a>
              <br><br>
            </li>
            <li>
              Atention aux <a href="">normals</a>
              <br><br>
            </li>
            <li>
              aux <a href="">UV maps</a>
              <br><br>              
            </li>
          </ul>
          <div class="fragment fade-in" data-fragment-index="1">
            <small>ex 2.3</small>
            <iframe data-src="lib/examples/ex2.3.html" style="width: 40%; float:right; height: 500px"></iframe>
          </div>
        </section>

        <section>
          <h2>Attention, chérie, ça va lagguer...</h2>
          <ul style="margin-top: 45px; width:55%; float:left">
            <li>
              Mesurer, mesurer, toujours mesurer
              <ul>
                <li><a href="https://github.com/mrdoob/stats.js">Stats.js</a></li>
                <li>outils de dévelopement</li>
              </ul>
              <br>
            </li>
            <li>
              Gérer la mémoire disponible<br>
              <ul>
                <li>objectif: pas de `new`</li>
                <li>utilisez des pools d'objets</li>
              </ul>
              <br>
            </li>
            <li>
              <!-- Buffers = Calls = temps -->
              Fusionner les geométries
              <ul>
                <li>10 objets => 1 objet</li>
                <li>10 appels au GPU => 1 seul</li>
                <li><i>BufferGeometry</i></li>
              </ul>
            </li>
          </ul>
          <small>ex 3</small>
          <iframe data-src="lib/examples/ex3.html" style="width: 40%; float:right; height: 500px"></iframe>
        </section>

        <section>
          <h2>Bac à sable</h2>
          <div><small>ex 3.3</small></div>
          <iframe data-src="lib/examples/ex3.3.html" style="width: 90%; height: 500px"></iframe>
          <aside class="notes">
            <ul>
              <li>Activer Stats.js</li>
              <li>Changer les 10 en 100, puis en 1000</li>
              <li>Montrer les audits Firebug, les outils WebGL Inspector</li>
              <li></li>
            </ul>
          </aside>
        </section>

        <section>
          <h2>Pour aller plus loin</h2>
          <br>
          <ul style="width:90%; margin:0">
            <li>
              <a href="">Shaders</a>
              <ul>
                <li>Fragments de code OpenGL exécutés par le GPU</li>
                <li>Permet de définir la couleur de chaque pixel d'un objet</li>
                <li>Bien plus rapide que les textures par images</li>
              </ul>
              <br><br>
            </li>
            <li>
              <a href="">EffectComposer</a>
              <ul>
                <li>Permet d'ajouter des effets sur le rendu</li>
                <li>Avant, ou après le rendu</li>
              </ul>
              <br><br>
            </li>
            <li>
              <a href="http://chandlerprall.github.io/Physijs">Physijs</a> un moteur physique pour Three.js
            </li>
            <li>
              <a href="https://github.com/jeromeetienne/threex">Threex</a> éléments de jeu
            </li>
            <li>
              <a href="http://stemkoski.github.io/Three.js/">stemkoski.github.io</a> d'autres exemples
            </li>
          </ul>
        </section>

        <section>
          <h2>But there's a challenger<br>Babylon.js !</h2>
          <br>
          <ul>
            <li>
              créé en <a>2013</a> par <a href="http://twitter.com/@deltakosh">David CATUHE</a>, développeur chez <a href="#">Microsoft</a>
              <br><br>
            </li>
            <li>
              <a href="">450</a> commits, <a href="">32</a> releases, <a href="">25</a> contributors
              <br><br>
            </li>
            <li>
              Énormément de features, de formats de fichiers supportés
              <br><br>
            </li>
            <li>
              Ce serait vraiment beau, n'est-ce pas ?
              <br>

              <p class="fragment fade-in" data-fragment-index="3">
                <img src="lib/img/how-about-no-bear.jpg" style="float:right; width:40%; margin:20px"/>
              </p>
              
              <p class="fragment fade-in" data-fragment-index="1">
                ... et bien ...
              </p>
              <p class="fragment fade-in" data-fragment-index="2">
                La dernière démo, annoncée via tweet sponsorisé par <a href="http://twitter.com/@IEDevChat">IEDevChat</a>, ne fonctionnait complètement que sous IE11 ...
                <br><br>
              </p>
            </li>
          </ul>
        </section>

        <section>
          <h1>THE END</h1>
          <iframe data-src="lib/examples/end.html" style="width: 80%; height: 500px"></iframe>
          <p>Retrouvez cette présentation sur Github http://vincent.github.io/three-prez</p>
        </section>

      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>
    <script src="lib/js/jquery-1.9.1.js"></script>

    <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: 'night', // Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Parallax scrolling
        // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
        // parallaxBackgroundSize: '2100px 900px',

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });

      /* * /
      Reveal.addEventListener('ready', function(event) {
          // event.currentSlide, event.indexh, event.indexv
          $('iframe').each(function(i, iframe){
            iframe.src = $(iframe).data('src');
            console.log('show iframe ', iframe);
          });
      });
      /* */

      /* */
      Reveal.addEventListener('slidechanged', function(event) {
          // event.previousSlide, event.currentSlide, event.indexh, event.indexv
          $('iframe', event.currentSlide).each(function(i, iframe){
            iframe.src = $(iframe).data('src');
            console.log('show iframe ', iframe);
          });
          // $('iframe', event.previousSlide).each(function(i, iframe){
          //   iframe.src = '';
          //   console.log('abort iframe ', iframe);
          // });
      });
      /* */

      /* * /
      Reveal.addEventListener('fragmentshown', function(event) {
          // event.fragment = the fragment DOM element
          $('iframe', event.fragment).each(function(i, iframe){
            iframe.src = $(iframe).data('src');
            console.log('show iframe ', iframe);
          });
      });
      /* */

    </script>

  </body>
</html>
